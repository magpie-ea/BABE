defmodule Magpie.ParticipantSocket do
  @moduledoc """
  The socket that every experiment participant connects to.

  After the refactoring, it might simply be the case that every experiment participant, regardless of the experiment type, connects to this socket, so that we have a uniform experience.
  """

  alias Magpie.Experiments
  alias Magpie.Experiments.{AssignmentIdentifier, Experiment, Slots}
  alias Magpie.Repo

  require Ecto.Query
  require Logger

  use Phoenix.Socket

  ## Channels
  # The ":*" part just means that any event with `participant` topic will be sent to the Participant channel.

  # Participant Channel is responsible for holding 1-to-1 connections with each participant.
  channel("participant:*", Magpie.ParticipantChannel)

  # Interactive room is for interactive experiments where multiple participants are present.
  channel("interactive_room:*", Magpie.InteractiveRoomChannel)

  # Iterated lobby is for iterated experiments
  # where future generations need to wait on results from previous generations.
  channel("iterated_lobby:*", Magpie.IteratedLobbyChannel)

  # Socket params are passed from the client and can
  # be used to verify and authenticate a participant. After
  # verification, you can put default assigns into
  # the socket that will be set for all channels, ie
  #
  #     {:ok, assign(socket, :participant_id, verified_participant_id)}
  #
  # To deny connection, return `:error`.
  #
  # See `Phoenix.Token` documentation for examples in
  # performing token verification on connect.

  # def connect(_params, socket) do
  #   {:ok, socket}
  # end

  # The "participant_id" is just a string randomly generated by the frontend to uniquely identify the participant. We don't have registration mechanisms for the participants for now.
  def connect(%{"participant_id" => participant_id, "experiment_id" => experiment_id}, socket) do
    with false <- participant_id == "",
         experiment when not is_nil(experiment) <- Repo.get(Experiment, experiment_id),
         true <- experiment.active,
         {:ok, next_slot} when not is_nil(next_slot) <-
           Slots.get_and_set_to_in_progress_next_free_slot(experiment) do
      num_players = Map.get(experiment.trial_players, next_slot)

      assignment_identifier = "#{experiment_id}_#{next_slot}"

      Logger.log(
        :info,
        "participant with id #{participant_id} is joining. They are assigned the assignment #{assignment_identifier}"
      )

      {:ok,
       socket
       |> assign(:participant_id, participant_id)
       |> assign(:experiment_id, experiment_id)
       |> assign(
         :assignment_identifier,
         assignment_identifier
       )
       |> assign(:num_players, num_players)}
    else
      # It seems that socket doesn't allow for sending specialized error messages. Just send :error
      _ -> :error
    end
  end

  # The incoming payload doesn't have the participant_id and experiment_id fields. Reject connection.
  def connect(_params, _socket), do: :error

  # Socket id's are topics that allow you to identify all sockets for a given participant:
  #
  #     def id(socket), do: "participants_socket:#{socket.assigns.participant_id}"
  #
  # Would allow you to broadcast a "disconnect" event and terminate
  # all active sockets and channels for a given participant:
  #
  #     Magpie.Endpoint.broadcast("participants_socket:#{participant.id}", "disconnect", %{})
  #
  # Returning `nil` makes this socket anonymous.
  def id(socket), do: "participant_socket:#{socket.assigns.participant_id}"
end
