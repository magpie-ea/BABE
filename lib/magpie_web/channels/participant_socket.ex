defmodule Magpie.ParticipantSocket do
  @moduledoc """
  The socket that every experiment participant connects to.

  At the moment, all the channels in Magpie are based on this socket.

  Flow of a complex experiment:
  1. The participant connects with this socket
  2. If the experiment is interactive, the participant joins InteractiveRoomChannel under the room `experiment_id:chain:variant:generation`.
    Once the number of participants is reached, the experiment starts.
  3. If the experiment is dynamic, the participant joins IteratedLobbyChannel under the room `experiment_id:chain:variant:generation`. Note that the assignment identifier for the lobby does NOT refer to the assignment identifier of the participant themselves, but rather, the assignment identifier on which the participant intends to wait for results to become available.
    Once the result from the experiment `experiment_id:chain:variant:generation` is available, the experiment starts.

  Note: There is no restriction on an experiment being both interactive AND dynamic. In this case, the participant will join both channels described in 2. and 3. It's up to the frontend to decide when to start the experiment.
  """

  alias Magpie.Repo
  alias Magpie.Experiments
  alias Magpie.Experiments.{AssignmentIdentifier, Experiment, Slots}

  require Ecto.Query
  require Logger

  use Phoenix.Socket

  ## Channels
  # The ":*" part just means that any event with `participant` topic will be sent to the Participant channel.

  # Participant Channel is responsible for holding 1-to-1 connections with each participant.
  channel("participant:*", Magpie.ParticipantChannel)

  # Interactive room is for interactive experiments where multiple participants are present.
  channel("interactive_room:*", Magpie.InteractiveRoomChannel)

  # Iterated lobby is for iterated experiments where future generations need to wait on results from previous generations.
  channel("iterated_lobby:*", Magpie.IteratedLobbyChannel)

  # Socket params are passed from the client and can
  # be used to verify and authenticate a participant. After
  # verification, you can put default assigns into
  # the socket that will be set for all channels, ie
  #
  #     {:ok, assign(socket, :participant_id, verified_participant_id)}
  #
  # To deny connection, return `:error`.
  #
  # See `Phoenix.Token` documentation for examples in
  # performing token verification on connect.

  # def connect(_params, socket) do
  #   {:ok, socket}
  # end

  # The "participant_id" is just a string randomly generated by the frontend to uniquely identify the participant. We don't have registration mechanisms for the participants for now.
  def connect(%{"participant_id" => participant_id, "experiment_id" => experiment_id}, socket) do
    with false <- participant_id == "",
         experiment when not is_nil(experiment) <- Repo.get(Experiment, experiment_id),
         true <- experiment.active,
         {:ok, next_slot} when not is_nil(next_slot) <-
           Slots.get_and_set_to_in_progress_next_free_slot(experiment) do
      Logger.log(
        :info,
        "participant with id #{participant_id} is joining. They are assigned the assignment #{next_slot}"
      )

      {:ok,
       socket
       |> assign(:participant_id, participant_id)
       |> assign(
         :assignment_identifier,
         next_slot
       )
       # Only need to keep track of this so that we know when to start an interactive experiment.
       |> assign(:num_players, experiment.num_players)}
    else
      # It seems that socket doesn't allow for sending specialized error messages. Just send :error
      _ -> :error
    end
  end

  # The incoming payload doesn't have the participant_id and experiment_id fields. Reject connection.
  def connect(_params, _socket), do: :error

  # Socket id's are topics that allow you to identify all sockets for a given participant:
  #
  #     def id(socket), do: "participants_socket:#{socket.assigns.participant_id}"
  #
  # Would allow you to broadcast a "disconnect" event and terminate
  # all active sockets and channels for a given participant:
  #
  #     Magpie.Endpoint.broadcast("participants_socket:#{participant.id}", "disconnect", %{})
  #
  # Returning `nil` makes this socket anonymous.
  def id(socket), do: "participant_socket:#{socket.assigns.participant_id}"
end
