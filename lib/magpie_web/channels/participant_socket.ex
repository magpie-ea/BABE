defmodule Magpie.ParticipantSocket do
  @moduledoc """
  The socket that every experiment participant connects to.

  After the refactoring, it might simply be the case that every experiment participant, regardless of the experiment type, connects to this socket, so that we have a uniform experience.
  """

  alias Magpie.Repo

  require Ecto.Query
  require Logger

  use Phoenix.Socket

  ## Channels
  # Participant Channel is responsible for holding 1-to-1 connections with each participant.
  # The ":*" part just means that any event with `participant` topic will be sent to the Participant channel.
  channel("participant:*", Magpie.ParticipantChannel)

  # Socket params are passed from the client and can
  # be used to verify and authenticate a participant. After
  # verification, you can put default assigns into
  # the socket that will be set for all channels, ie
  #
  #     {:ok, assign(socket, :participant_id, verified_participant_id)}
  #
  # To deny connection, return `:error`.
  #
  # See `Phoenix.Token` documentation for examples in
  # performing token verification on connect.

  # def connect(_params, socket) do
  #   {:ok, socket}
  # end

  # The "participant_id" is just a string randomly generated by the frontend to uniquely identify the participant. We don't have registration mechanisms for the participants for now.
  # So when the participant first connects, let's not do anything, and simply let them queue up and join the ParticipantChannel.
  # It's the `AssignExperimentSlotsWorker`'s responsibility to periodically scan and assign slots, if they are available.
  # Now that I think about it, there could also just be one global worker each taking care of all experiments... Will that be fast enough though. That will likely cause a bottleneck, right? Let's see then.
  # So yeah, turns out the backend doesn't need to do anything. The frontend will need to join the participant channel immediately afterwards. Indeed.
  def connect(%{"participant_id" => participant_id, "experiment_id" => experiment_id}, socket) do
    with false <- participant_id == "",
         experiment when not is_nil(experiment) <- Repo.get(Experiment, experiment_id),
         true <- experiment.active do
      {:ok,
       socket
       |> assign(:participant_id, participant_id)
       |> assign(:experiment_id, experiment_id)}
    else
      # It seems that socket doesn't allow for sending specialized error messages. Just send :error
      _ -> :error
    end
  end

  # The incoming payload doesn't have the participant_id and experiment_id fields. Reject connection.
  def connect(_params, _socket), do: :error

  # Socket id's are topics that allow you to identify all sockets for a given participant:
  #
  #     def id(socket), do: "participants_socket:#{socket.assigns.participant_id}"
  #
  # Would allow you to broadcast a "disconnect" event and terminate
  # all active sockets and channels for a given participant:
  #
  #     Magpie.Endpoint.broadcast("participants_socket:#{participant.id}", "disconnect", %{})
  #
  # Returning `nil` makes this socket anonymous.
  def id(socket), do: "participant_socket:#{socket.assigns.participant_id}"
end
